c-----------------------------------------------------------------------
c
c     Plane wave striking a cylindrical resonator
c
c-----------------------------------------------------------------------
       subroutine userinc(tt,incfhx,incfhy,incfhz,incfex,incfey,incfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /userparam/ omega,period
      real omega,period

      common /userincident/ ninc,incindex(lxzfl)
      integer ninc,incindex

      real tt
      real incfhx(lxzfl),incfhy(lxzfl),incfhz(lxzfl)
      real incfex(lxzfl),incfey(lxzfl),incfez(lxzfl)

      integer i,j,k
      real yy,eps,mu,ky,eta,uinc
      real ramp

      do i = 1,ninc
         j = incindex(i)
         k = cemface(j)
         yy = ym1(k,1,1,1)
         eps = permittivity(k)
         mu = permeability(k)
         eta = sqrt(mu/eps)
         ky = omega*sqrt(mu*eps)
         uinc = ramp(tt/(3.0*period))*sin(ky*yy-omega*tt)
         incfhx(j) = incfhx(j)+uinc
         incfey(j) = incfey(j)+eta*uinc
      enddo

      return
      end
c-----------------------------------------------------------------------
      function ramp(tt)
c-----------------------------------------------------------------------
c     Monotonic function that goes from 0 to 1 on the interval [0, 1].
      implicit none

      real ramp
      real tt

      ramp = 0.5*(1.0+erf(5.0*tt-5.0))

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,hx,hy,hz,ex,ey,ez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real hx(lpts),hy(lpts),hz(lpts)
      real ex(lpts),ey(lpts),ez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,solhx,solhy,solhz,solex,soley,solez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real solhx(lpts),solhy(lpts),solhz(lpts)
      real solex(lpts),soley(lpts),solez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srchx(lpts),srchy(lpts),srchz(lpts)
      real srcex(lpts),srcey(lpts),srcez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine userfsrc(tt,srcfhx,srcfhy,srcfhz,srcfex,srcfey,srcfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srcfhx(lxzfl),srcfhy(lxzfl),srcfhz(lxzfl)
      real srcfex(lxzfl),srcfey(lxzfl),srcfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'PML'

      common /userparam/ omega,period
      real omega,period

      common /userincident/ ninc,incindex(lxzfl)
      integer ninc,incindex

      common /scaling/ length,sxy,sz,radius,gap,height
      real length,sxy,sz,radius,gap,height

c     These don't do anything! This is a temporary measure until
c
c     https://github.com/NekCEM/NekCEM/issues/12
c
c     is resolved.
      integer ix,iy,iz,iel

      logical markinc
      integer i,e,f,j,k
      integer nx1_2
      real c0,lambda,twopi
      real xx,yy,zz,rr
      parameter (
     $     c0 = 299792458,      ! speed of light, in m/s
     $     twopi = 8.0*atan(1.0))

c     Wavelength of the incident wave, in m
      lambda = 480e-9
c     Nondimensionalize the wavelength
      lambda = lambda/length
      omega = twopi/lambda
      period = twopi/omega
      if (nid.eq.0) then
         write(*,*) 'uservp: wavelength lambda = ',lambda
         write(*,*) 'uservp: frequency omega = ',omega
         write(*,*) 'uservp: period = ',period
      endif

      nx1_2 = nx1/2
c     Set the permittivities
      do e = 1,nelt
        xx = xm1(nx1_2,nx1_2,nx1_2,e)
        yy = ym1(nx1_2,nx1_2,nx1_2,e)
        zz = zm1(nx1_2,nx1_2,nx1_2,e)
        rr = sqrt(xx**2+yy**2)

        if (rr.lt.radius.and.abs(zz).lt.0.5*height) then
           write(*,*) 'aaa',rr,zz
c     Inside the resonator
           do i = 1,nxyz
              j = i+nxyz*(e-1)
              permittivity(j) = 130.0
              permeability(j) = 1.0
           enddo
        else
c     Outside the resonator
           do i = 1,nxyz
              j = i+nxyz*(e-1)
              permittivity(j) = 1.4
              permeability(j) = 1.0
           enddo
        endif
      enddo

c     Mark where the incident field needs to be added
      ninc = 0
      do e = 1,nelt
         do f = 1,nfaces
            markinc = .true.
            do i = 1,nxzf
c     j is the global face number
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
c     k is the volume global number associated with face j.
               k = cemface(j)
               if (pmltag(e).eq.0
     $              .or.abs(pmlinner(6)-zm1(k,1,1,1)).gt.1e-8) then
                  markinc = .false.
                  exit
               endif
            enddo
            if (markinc) then
               do i = 1,nxzf
                  ninc = ninc+1
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  incindex(ninc) = j
               enddo
            endif
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      implicit none

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'GEOM'
      include 'PML'

      common /scaling/ length,sxy,sz,radius,gap,height
      real length,sxy,sz,radius,gap,height

      integer i,nz
      real xmin,xmax,ymin,ymax,zmin,zmax
      real glmax,glmin

c     Number of layers in the z direction
      nz = 7
c     Characteristic length to use in nondimensionalization in m
      length = 100.0e-9
c     Gap between cylinders in m
      gap = 48e-9
c     Radius of the cylinder in m
      radius = 115e-9
c     Height of the cylinder in m
      height = 135e-9
c     Nondimensionalize
      gap = gap/length
      radius = radius/length
      height = height/length

c     Common xy scaling
      sxy = gap+2.0*radius
c     Scale by (nz layers)/(nz - (layers for pml + buffer layers))
      sz = (dble(nz)/dble(nz-2*pmlthick-2))*height

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)
      zmin = glmin(zm1,npts)
      zmax = glmax(zm1,npts)

      do i = 1,npts
         xm1(i,1,1,1) = sxy*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-0.5*sxy
         ym1(i,1,1,1) = sxy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-0.5*sxy
         zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-0.5*sz
      enddo

      xmin = glmin(xm1,npts)
      xmax = glmax(xm1,npts)
      ymin = glmin(ym1,npts)
      ymax = glmax(ym1,npts)
      zmin = glmin(zm1,npts)
      zmax = glmax(zm1,npts)

      if (nid.eq.0) then
         write(*,*) 'usrdat2: cylinder radius = ',radius
         write(*,*) 'usrdat2: cylinder height = ',height
         write(*,*) 'usrdat2: cylinder gap = ',gap
         write(*,*) 'usrdat2: xmin,xmax = ',xmin,xmax
         write(*,*) 'usrdat2: ymin,ymax = ',ymin,ymax
         write(*,*) 'usrdat2: zmin,zmax = ',zmin,zmax
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk
      real cpu_t,cpu_dtime,cpu_chk

      real cpu_p_t
      real l2(6),linf(6)

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol
     $     (time,shn(1,1),shn(1,2),shn(1,3),sen(1,1),sen(1,2),sen(1,3))
         call cem_error(hn(1,1),shn(1,1),errhn(1,1),npts,l2(1),linf(1))
         call cem_error(hn(1,2),shn(1,2),errhn(1,2),npts,l2(2),linf(2))
         call cem_error(hn(1,3),shn(1,3),errhn(1,3),npts,l2(3),linf(3))
         call cem_error(en(1,1),sen(1,1),erren(1,1),npts,l2(4),linf(4))
         call cem_error(en(1,2),sen(1,2),erren(1,2),npts,l2(5),linf(5))
         call cem_error(en(1,3),sen(1,3),erren(1,3),npts,l2(6),linf(6))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
